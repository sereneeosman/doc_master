<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Intergrated Data Analysis &mdash; SereneeOsman Guidance</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=c01f9344" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../_static/copybutton.js?v=8b21d8d7"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1. Sphinx and HTML Web Publishing" href="../Other/Sphinx_and_HTML_Web_Publishing.html" />
    <link rel="prev" title="1. NI Tourist Map" href="NI_Tourist_Map_doc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SereneeOsman Guidance
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Other/About_Me.html">1. About Me</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tourist Map:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="NI_Tourist_Map_doc.html">1. NI Tourist Map</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Intergrated Data Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other :</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Other/Sphinx_and_HTML_Web_Publishing.html">1. Sphinx and HTML Web Publishing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SereneeOsman Guidance</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">2. </span>Intergrated Data Analysis</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/sereneeosman/sereneeosman_doc/blob/main/docs/sourceegm722_serenee/Integrated_Data_Analysis_doc.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>#!/usr/bin/env python
# coding: utf-8</p>
<section id="intergrated-data-analysis">
<h1><span class="section-number">2. </span>Intergrated Data Analysis<a class="headerlink" href="#intergrated-data-analysis" title="Link to this heading"></a></h1>
<p># ## 1. Fixing Geometry in Shapefiles #
#
# the process of repairing or adjusting the geometric properties of __spatial <a href="#id17"><span class="problematic" id="id18">data__</span></a>, such as __points__, __lines__, or __polygons__, to ensure they meet certain criteria or standards. This could involve tasks such as removing or correcting invalid geometries, simplifying shapes, snapping vertices to a grid, or resolving topological errors. Libraries such as <cite>Shapely</cite> and <cite>GeoPandas</cite> provide functionality to perform these operations efficiently.
#</p>
<p># ### Getting Started
# The geopandas package offers a range of functionalities for performing various operations and analyses on vector geospatial data (a [GeoDataFrame](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/geodataframe.html">https://geopandas.org/en/stable/docs/reference/geodataframe.html</a>)).
#
# Importing the <cite>geopandas</cite> library with the alias <cite>gpd</cite> ,it provides a shorter and easier-to-use name for referencing the library’s functions and objects throughout the code.</p>
<p># In[ ]:</p>
<p>import geopandas as gpd</p>
<p># This code reads a shapefiles located in the data directory using <cite>geopandas</cite> library.
# Read the country outline shapefile.</p>
<p># In[ ]:</p>
<p># Read the shapefile
input_data = gpd.read_file(“data_files/download_data/<a href="#id25"><span class="problematic" id="id26">OSNI_Open_Data_</span></a>-_Largescale_Boundaries_-_NI_Outline.shp”)  # Path to the input shapefile</p>
<p># Fixing the geometry of [GeoDataFrame](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/geodataframe.html">https://geopandas.org/en/stable/docs/reference/geodataframe.html</a>) by applying the [buffer method](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.buffer.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.buffer.html</a>) with a Zero distance. This approach can help resolve common geometry issues such as self-intersections and degenerate geometries.</p>
<p># In[ ]:</p>
<p># Fix geometries using buffer method
fix_data = input_data.buffer(0)</p>
<p># [.to_crs()](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html</a>) method in <cite>GeoPandas</cite> is used to transform all geometries from an active coordinate reference system ([CRS](<a class="reference external" href="https://geopandas.org/en/stable/docs/user_guide/projections.html">https://geopandas.org/en/stable/docs/user_guide/projections.html</a>)) to another specified CRS. It allows you to convert the spatial data in your __GeoDataFrame__ to a different CRS, ensuring consistency or enabling analysis in a different geographic context.
#
# Re-project the <cite>crs</cite> to WGS84 latitude/longitude [(EPSG:4326)](https://epsg.io/4326)</p>
<p># In[ ]:</p>
<p># Set CRS to WGS84
fixed_data = fix_data.to_crs(“epsg:4326”)</p>
<p># The`.to_file` [(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html</a>) function saves the fixed geometries __GeoDataFrame__,into new shapefile.</p>
<p># In[ ]:</p>
<p># Save the fixed geometries to a new shapefile
fixed_data.to_file(“data_files/NI_Outline.shp”) # Path to the fixed output shapefile</p>
<p># You are free to utilize the output data for analysis.</p>
<p># ## 2. Coordinate Reference System (CRS) Re-Projection
#
# Coordinate Re-Projection[(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/user_guide/projections.html#re-projecting">https://geopandas.org/en/stable/docs/user_guide/projections.html#re-projecting</a>) is the process of transforming coordinates from one Coordinate Reference System (CRS)[(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/user_guide/projections.html">https://geopandas.org/en/stable/docs/user_guide/projections.html</a>) to another. A <cite>CRS</cite> is a framework used to specify locations on the Earth’s surface. It’s essentially a coordinate-based system that allows for the precise identification of geographic features and positions.
#
# ### Getting Started
# Importing the geopandas library with the alias gpd ,it provides a shorter and easier-to-use name for referencing the library’s functions and objects throughout the code.</p>
<p># In[ ]:</p>
<p>import geopandas as gpd</p>
<p># This code reads a shapefiles (a [__GeoDataFrame__](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/geodataframe.html">https://geopandas.org/en/stable/docs/reference/geodataframe.html</a>)) located in the data directory using “geopandas” library.</p>
<p># In[ ]:</p>
<p># Read the downloaded shapefiles
tourist_tmp = gpd.read_file(“data_files/download_data/Historic_Parks_and_Gardens20240410.shp”)  # Path to the input shapefile of Historic Park and Garden Data.</p>
<p># [.to_crs()](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html</a>) method in GeoPandas is used to transform all geometries from an active coordinate reference system ([CRS](<a class="reference external" href="https://geopandas.org/en/stable/docs/user_guide/projections.html">https://geopandas.org/en/stable/docs/user_guide/projections.html</a>)) to another specified CRS. It allows you to convert the spatial data in your GeoDataFrame to a different CRS, ensuring consistency or enabling analysis in a different geographic context.
#
# Re-project the <cite>crs</cite> to WGS84 latitude/longitude [(EPSG:4326)](https://epsg.io/4326)</p>
<p># In[ ]:</p>
<p># Set CRS to WGS84
tourist_prj = tourist_tmp.to_crs(“epsg:4326”)</p>
<p># The`.to_file` [(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html</a>) function saves the crs transform GeoDataFrame, into a new shapefile.</p>
<p># In[ ]:</p>
<p># Save the re-projected shapefile to a new shapefile
tourist_prj.to_file(“data_files/NI_Tourist_Sites.shp”) # Path to the output shapefile</p>
<p># You have successfully re-project the Shapefile.</p>
<p># ## 3. Clipping shapefiles
# Clipping shapefiles refers to the process of spatially limiting or cutting down the extent of a shapefile based on the boundary of another shapefile or a defined boundary area. When examining a shapefile of counties in ArcGIS or QGIS, you might notice that county boundaries extend across water features, which can be confusing for map users. To address this, we will refine the map by removing extraneous elements using the country’s outline border.
#
# ### Getting Started
#
# Importing the geopandas library with the alias gpd.
#</p>
<p># In[ ]:</p>
<p>import geopandas as gpd</p>
<p># Read the __GeoDataFrames__ of “counties shapefile” and the __geometry <a href="#id17"><span class="problematic" id="id19">fixed__</span></a> “country outline” data.</p>
<p># In[ ]:</p>
<p># Read the input and mask/clip shapefiles
input_counties = gpd.read_file(“data_files/download_data/<a href="#id27"><span class="problematic" id="id28">OSNI_Open_Data_</span></a>-_Largescale_Boundaries_-_County_Boundaries_.shp”)# Path to the input shapefile of County Boundaries
clip_data = gpd.read_file(“data_files/NI_outline.shp”)# path to the mask shapefile of geometry fixed country boarder</p>
<p># To ensure that all files are in a common <cite>CRS</cite> (Coordinate Reference System), we need to reproject the __GeoDataFrames__ using the  <a href="#id1"><span class="problematic" id="id2">`</span></a>.to_crs`[(documentation)](<a class="reference external" href="https://www.google.com/search?q=to_crs+geopandas&amp;rlz=1C1JCYX_jaJP1077JP1077&amp;oq=.to_crs+&amp;gs_lcrp=EgZjaHJvbWUqBggBEAAYHjIGCAAQRRg5MgYIARAAGB4yBggCEAAYHjIICAMQABgIGB4yCggEEAAYgAQYogQyCggFEAAYgAQYogQyCggGEAAYgAQYogQyCggHEAAYgAQYogTSAQgyODM5ajBqN6gCALACAA&amp;sourceid=chrome&amp;ie=UTF-8">https://www.google.com/search?q=to_crs+geopandas&amp;rlz=1C1JCYX_jaJP1077JP1077&amp;oq=.to_crs+&amp;gs_lcrp=EgZjaHJvbWUqBggBEAAYHjIGCAAQRRg5MgYIARAAGB4yBggCEAAYHjIICAMQABgIGB4yCggEEAAYgAQYogQyCggFEAAYgAQYogQyCggGEAAYgAQYogQyCggHEAAYgAQYogTSAQgyODM5ajBqN6gCALACAA&amp;sourceid=chrome&amp;ie=UTF-8</a>) fuction. In the previous step, the outline shapefile has already been reprojected into WGS84. Now, we need to transform the geometries of the GeoDataFrames called “input_counties” to the desired CRS, which in this case is WGS84.
#</p>
<p># In[ ]:</p>
<p># Re-project the CRS of the clipped data (assuming the original data uses the same CRS) WGS84 latitude/longitude(EPSG:4326)
prj_counties = input_counties.to_crs (“epsg:4326”)</p>
<p># <a href="#id3"><span class="problematic" id="id4">`</span></a>.crs`[(documentation)](<a class="reference external" href="https://geopandas.org/en/latest/docs/reference/api/geopandas.GeoDataFrame.crs.html">https://geopandas.org/en/latest/docs/reference/api/geopandas.GeoDataFrame.crs.html</a>) function use for check the existing CRS  of __GeoDataFrames__.</p>
<p># In[ ]:</p>
<p>Verification of existing CRS
prj_counties.crs</p>
<p># Next, we’re going to clip the counties polygon layer using an outline polygon layer. Both GeoDataFrames have the same Coordinate Reference System (CRS).
# * <cite>gpd.overlay`[(documentation)](https://geopandas.org/en/stable/docs/reference/api/geopandas.overlay.html) function overlaying two GeoDataFrames to compute spatial overlay operations, such as intersection, union, or difference.
#
# * `prj_counties</cite> and <cite>clip_data</cite> represent GeoDataFrames containing geographic data, with prj_counties likely representing the __input <a href="#id17"><span class="problematic" id="id20">feature__</span></a> and clip_data representing the __feature used for <a href="#id17"><span class="problematic" id="id21">clipping__</span></a> (e.g., a boundary or mask).
#
# * <cite>keep_geom_type=True</cite> This parameter specifies whether to keep the geometry types of the input GeoDataFrames in the output GeoDataFrame. By setting it to True, the output will retain the geometry types of both prj_counties and clip_data.</p>
<p># In[ ]:</p>
<p>#Clipping the counties polygon layer using an outline polygon layer
clipped_counties = gpd.overlay(prj_counties, clip_data, how=’intersection’, keep_geom_type=True)</p>
<p># Save the result as ashapefile.
#
# <a href="#id5"><span class="problematic" id="id6">`</span></a>.to_fil`[(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_file.html</a>) function allows to save new GeoDataFrame.</p>
<p># In[ ]:</p>
<p># Save the clipped data to a new shapefile
clipped_counties.to_file(“data_files/NI_Counties.shp”) # Path to the fixed output shapefile of County Boundaries</p>
<p># You have successfully clipped the counties polygons using country outline data.</p>
<p># ## 4. Data Intergration
#
# Python typically refers to the process of combining data from multiple sources, formats, or databases into a unified format that can be analyzed or used for further processing.
#
# ### i. Integrating GP Surgeries Data by Postal Code
# We’re going to combine the data from GP surgery with postal code data, creating a unified dataset that includes information from both sources.
#
# ### Getting Started
# In this step, we will merge two DataFrames and generate a GeoDataFrame as the output.
#
# Import the necessary libraries.
#</p>
<p># In[ ]:</p>
<p>import pandas as pd
import geopandas as gpd</p>
<p># Read the __DataFrame__
#
# The <cite>.read_csv()`[(documentation)](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html) function in `Pandas</cite> is used to read data from CSV (Comma Separated Values) files and load it into a __DataFrame__, which is a tabular data structure similar to a spreadsheet or a database table.</p>
<p># In[ ]:</p>
<p># Load csv data sets
uk_postcodes = pd.read_csv(“data_files/download_data/ukpostcodes.csv”) # path to UK postal code csv file
gp_practices = pd.read_csv(“data_files/download_data/gp-practice-reference-file—jan-2024.csv”) #path to GP practice csv file</p>
<p># Inspect the __DataFrame__ headers to identify a common column that can be used for integrating the __DataFrames__.
#
# The <cite>.head()`[(documentation)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html) method in Pandas is used to display the first few rows of a __DataFrame__. By default, it shows the first 5 rows, but you can specify a different number of rows by passing an integer argument to the method `.head(n)</cite>.</p>
<p># Check the first few rows of the “uk_postcodes” DataFrame</p>
<p># In[ ]:</p>
<p># check the header of uk_postcodes DataFrame
uk_postcodes.head()</p>
<p># Check the first few rows of the “gp_practices” DataFrame</p>
<p># In[ ]:</p>
<p># check the header of gp_practices DataFrame
gp_practices.head()</p>
<p># This code merges two DataFrame, namely “uk_postcode”s and “gp_practices”, based on a common column in each dataset.
#
# * The <cite>.merge`([documentation](https://pandas.pydata.org/docs/reference/api/pandas.merge.html)),fuction provided attempts to merge the two datasets. Merge these datasets based on a common field (the “postcode”[uk_postcodes] and “Postcode”[gp_practices] columns)
#
# * The `left_on</cite>, parameter specifies the column name in the left dataset (uk_postcodes) to use for merging (in this case, “postcode”).
#
# * The <cite>right_on</cite>, parameter specifies the column name in the right dataset (gp_practices) to use for merging (in this case, “Postcode”).
#
# * <cite>how=”inner”</cite>, parameter specifies the type of merge to perform. In this case, an inner join is performed, meaning only the rows with matching postal codes in both __DataFrames__ will be included in the merged __DataFrame__.</p>
<p># In[ ]:</p>
<p># merge datasets base on postal code
merge_data = pd.merge(uk_postcodes, gp_practices, left_on=”postcode”, right_on=”Postcode” , how=”inner”)</p>
<p># The <cite>.head()</cite> method is then called on the merged DataFrame to display the first few rows. By default, it shows the first five rows, along with the column names.</p>
<p># In[ ]:</p>
<p>#check the header of merged data
merge_data.head()</p>
<p># The downloaded postal code file contains postal codes for the entire United Kingdom (UK). However, for this project, we are only interested in the territory of Northern Ireland, which has postal codes starting with “BT”. In this step, we will filter the rows of the __DataFrame__ to include only those with postal codes starting with “BT”.
#
# The <cite>.str.startswith() ` [(documentation)](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.startswith.html)  method is a string accessor available in `Pandas</cite> that is applied to a Series containing strings. It checks whether each string in the Series starts with a specified prefix and returns a boolean Series indicating the result of this check for each string.
#
# * The <cite>.str</cite>,is a Pandas accessor that allows you to apply string methods to each element of a Series.
# * The <cite>.startswith(“BT”)</cite>,is a string method that checks if each string in the Series starts with the specified substring, in this case, “BT”. It returns a boolean Series where each element indicates whether the corresponding string starts with “BT”.</p>
<p># In[ ]:</p>
<p># Filtering Northern Ireland postcodes
ni_postcodes_tmp = merge_data[merge_data[“postcode”].str.startswith(“BT”)]</p>
<p># In this step, we are removing unnecessary columns from the DataFrame
#
# <a href="#id7"><span class="problematic" id="id8">`</span></a>.drop`[(documentation)](<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html</a>)  method remove the specified columns on the __DataFrame__. parameter is used to specify the names of the columns to be dropped, provided as a list and returns a new __DataFrame__ with the specified columns removed.</p>
<p># In[ ]:</p>
<p># remove unnecessary columns
ni_postcodes = ni_postcodes_tmp.drop(columns=[“id” , “Postcode”, “LCG” , “Registered_Patients”])</p>
<p># Verify the resulting __DataFrame__ using the <cite>.head</cite> fucntion.</p>
<p># In[ ]:</p>
<p># Verify the resulting DataFrame.
ni_postcodes.head()</p>
<p># We’ll create a new GeoDataFrame from an existing DataFrame.
#
# The <a href="#id9"><span class="problematic" id="id10">`</span></a>gpd.GeoDataFrame`[(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html</a>) function from the “GeoPandas” library is used to create a __GeoDataFrame__ from a regular DataFrame
#
# <a href="#id11"><span class="problematic" id="id12">`</span></a>.points_from_xy`[(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html</a>) function specifies the geometry column of the GeoDataFrame. In this case, it creates a new geometry column by converting latitude and longitude coordinates into Point geometries. The __longitude__ and __latitude__ columns from the DataFrame “ni_postcodes” are used as inputs.</p>
<p># In[ ]:</p>
<p># convert the Dataframe to a Geodataframe
ni_postcodes_geo = gpd.GeoDataFrame(ni_postcodes, geometry=gpd.points_from_xy(ni_postcodes.longitude, ni_postcodes.latitude))</p>
<p># Save the GeoDataFrame as a GeoJSON file.
#
# * The <cite>.to_file</cite> [(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_json.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_json.html</a>) method is used to save the GeoDataFrame to a file.
#
# * The <cite>driver=”GeoJSON”</cite> parameter specifies the file format to use for saving the data. In this case, we’re using the GeoJSON format.</p>
<p># In[ ]:</p>
<p># Save the filtered dataset
ni_postcodes_geo.to_file(“data_files/NI_PostCodes_GP.geojson”, driver=”GeoJSON”)</p>
<p># You have successfully exported the GeoJSON file combining GP surgery details with postal codes.</p>
<p># ### ii. Distance Calculation.
# We’ll locate the closest transport hub along with its distance and also identify the nearest GP surgery and its distance from the tourist sites.
#
# ### Getting Started
# In this step, we will handle __GeoDataFrames__ and calculate the distances.
#
# Import the necessary libraries.</p>
<p># In[ ]:</p>
<p>import pandas as pd
import geopandas as gpd</p>
<p># Read previously projected tourist sites data(a __GeoDataFrame__).</p>
<p># In[ ]:</p>
<p># Read projected tourist data
tourist = gpd.read_file(“data_files/NI_Tourist_Sites.shp”)  # Path to the input shapefile of projected tourist sites</p>
<p># Check the first few rows and try to gain a better understanding of its contents.
# In this dataset, the <cite>geometry</cite> column represents spatial data in the form of “polygons”, which are geometric shapes defined by a series of connected points in space.</p>
<p># In[ ]:</p>
<p># verify the header
tourist.head()</p>
<p># Read the GeoJSON files and reproject them into the “Cartesian 2D” coordinate reference system([EPSG:2157,IRENET95 / Irish Transverse Mercator](https://epsg.io/2157)).
#
# The choice of coordinate system significantly influences the accuracy of __distance <a href="#id17"><span class="problematic" id="id22">calculations__</span></a> [(documentation)](<a class="reference external" href="https://automating-gis-processes.github.io/CSC/notebooks/L2/projections.html#Calculating-distances).This">https://automating-gis-processes.github.io/CSC/notebooks/L2/projections.html#Calculating-distances).This</a> “Cartesian 2D” coordinate reference system ([Projected Coordinate System](<a class="reference external" href="https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/#:~:text=A%20projected%20coordinate%20system%20(PCS)%20is%20a%20GCS%20that%20has,to%20know%20how%20to%20draw">https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/#:~:text=A%20projected%20coordinate%20system%20(PCS)%20is%20a%20GCS%20that%20has,to%20know%20how%20to%20draw</a>.)) is crucial for accurate distance calculations, as it uses “Cartesian coordinates” in “meters”, providing precise measurements over __flat <a href="#id17"><span class="problematic" id="id23">surfaces__</span></a>. WGS84, on the other hand, utilizes longitudes and latitudes in the [geographic coordinate system ](<a class="reference external" href="https://desktop.arcgis.com/en/arcmap/latest/map/projections/about-geographic-coordinate-systems.htm#:~:text=A%20geographic%20coordinate%20system%20(GCS,(based%20on%20a%20spheroid">https://desktop.arcgis.com/en/arcmap/latest/map/projections/about-geographic-coordinate-systems.htm#:~:text=A%20geographic%20coordinate%20system%20(GCS,(based%20on%20a%20spheroid</a>).) , which may not yield accurate distance measurements due to the Earth’s curved surface.
#</p>
<p># Read the downloaded Transport hub “geojson” data (a __GeoDataFrame__)</p>
<p># In[ ]:</p>
<p>#Read the downloaded Transport hub “geojson” and transform to Irish Transverse Mercator
transport = gpd.read_file(“data_files/download_data/translink-stations-ni.geojson”).to_crs(“epsg:2157”)</p>
<p># Read the previously integrated “geojson” dataset containing GP surgeries and postal codes (a __GeoDataFrame__).</p>
<p># In[ ]:</p>
<p>#Read the previously integrated “geojson” dataset containing GP surgeries and postal codes
# and re-Projected to Irish Transverse Mercator coordinate reference system
post_gp = gpd.read_file(“data_files/NI_PostCodes_GP.geojson”).to_crs(“epsg:2157”)</p>
<p># This code snippet iterates over each tourist site in the GeoDataFrame tourist, calculates the distance to the nearest bus/train station and the nearest GP surgery, and records the shortest distance in kilometers along with the name of the station.
#
# explanation of the code:
#
# * The <cite>for ind, row in tourist.to_crs(“epsg:2157”).iterrows()</cite> parameters “iterates over”(<cite>.iterrows()`[documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iterrows.html)) each row (“tourist”) in the _GeoDataFrame_ tourist, after projecting it to the Irish Transverse Mercator coordinate reference system (EPSG:2157) for distance calculations in meters.
#
# * The `pt = row[“geometry”].centroid</cite> [(documentation)](<a class="reference external" href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.centroid.html">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.centroid.html</a>): function calculates the centroid of each tourist site geometry(polygon).
#
# * The <cite>.distance()`[(documentation)](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.distance.html) function calculates the distance between the centroid of the tourist site and all train/bus stations stored in the __GeoDataFrame__, as well as all GP practices stored in the __GeoDataFrame__.
#
# * The</cite>.argmin()`[(documentation)](<a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.argmin.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.argmin.html</a>) method retrieves the index of the train/bus station with the shortest distance to the tourist site, as well as the index of the nearest GP surgery.
#
# * The <cite>.min()`[(documentation)](https://docs.python.org/3/library/functions.html#min) method retrieves the shortest distance to the nearest train/bus station in meters, as well as the shortest distance to the nearest GP surgery.
# * The `.loc`[(documentation)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html) indexer is a `Pandas</cite> method used for label-based indexing. It is primarily used to access and modify specific rows and columns of a __DataFrame__ based on their labels (row and column names). It allows you to select data by specifying the row labels and column names explicitly.
# * The <cite>tourist.loc[ind, “Near_T_Hub”] = transport.loc[min_ind_trans].Station.title()</cite> , line assigns the name of the nearest transport hub (train/bus station) to the “Near_T_Hub” column for the current tourist site. The <cite>.title()`[(documentation)](https://docs.python.org/3/library/stdtypes.html#str.title) is a built-in Python string method it capitalizes the first letter of each word in the station name.
# Omit the use of the `.title()</cite> method when assigning to the “GP practice name” because preserving the original case of the names is necessary for combining data in the next steps.The <cite>.merge</cite> function is Case sensitive.
#
# * <cite>/1000</cite> function convert meters into kilometers.
#</p>
<p># In[ ]:</p>
<p># for each tourist site centroid,find the closest bus/train station
# Record the Shortest distance in km and the name of the station.
for ind, row in tourist.to_crs(“epsg:2157”).iterrows():</p>
<blockquote>
<div><p>pt = row[“geometry”].centroid # get the centroid of the each tourist site polygon.</p>
<p>distance_trans = transport.distance(pt) # find the distance between the centroid and all train station
distance_postgp = post_gp.distance(pt) # find the distance between the centroid and all GP pratices</p>
<p>min_ind_trans = distance_trans.argmin() # get the index of minimum value
min_dist_trans = distance_trans.min() # get the minimum distance</p>
<p>min_ind_postgp = distance_postgp.argmin()
min_dist_postgp = distance_postgp.min()</p>
<p># define column header
tourist.loc[ind, “Near_T_Hub”] = transport.loc[min_ind_trans].Station.title() # assigns the name of the nearest transport hub and capitalizes the first letter of each word in the station name
tourist.loc[ind, “Near_GP”] = post_gp.loc[min_ind_postgp].PracticeName #assigns the name of the nearest GP Surgery</p>
<p># add distance to the closest transport hub
tourist.loc[ind, “Trans_Dist”] = min_dist_trans / 1000 # distance in km
tourist.loc[ind, “GP_Dist”] = min_dist_postgp / 1000</p>
</div></blockquote>
<p># The <a href="#id13"><span class="problematic" id="id14">`</span></a>.round()`[(documentation)](<a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.round.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.round.html</a>)  is used to round the distances to a specified number of decimal places.In this case, the distance values are being rounded to centimeter accuracy.</p>
<p># In[ ]:</p>
<p># round the distance to cm accuracy (2 decimal places)
tourist.Trans_Dist = tourist.Trans_Dist.round(2)
tourist.GP_Dist = tourist.GP_Dist.round(2)</p>
<p># First, let’s check the first few rows of the resulting “tourist” __GeoDataFrame__. Then, we’ll inspect the “Near_GP” column and verify that all row values are in uppercase. If any row values are not uppercase, we’ll need to go back to the previous cell and ensure that the <cite>.title()</cite> function has been removed for the “post_gp” __GeoDataFrame__.</p>
<p># In[ ]:</p>
<p>#check the header and verify that all index in the “PracticeName” column are in uppercase.
tourist.head() # check the header of final data set</p>
<p># Inspect the first few rows of the post_gp GeoDataFrame and examine the “PracticeName” column. You’ll observe that all row values are in uppercase.</p>
<p># In[ ]:</p>
<p>#check the header
post_gp.head()</p>
<p>#
# You’ll notice that both columns have common row values with uppercase letters. Maintaining case sensitivity is crucial when merging __DataFrames__.</p>
<p># Filter the necessary columns from the “tourist” __GeoDataFrame__ and create a new __DataFrame__ named “tourist_out”.</p>
<p># In[ ]:</p>
<p># Filter necessary columns
tourist_out = pd.DataFrame(tourist[[“SITE”, “Near_T_Hub”,”Trans_Dist”,”Near_GP”, “GP_Dist”]])</p>
<p># Inspect the first few rows of the tourist_out DataFrame</p>
<p># In[ ]:</p>
<p># verify the header
tourist_out.head()</p>
<p># Merge the __DataFrame__ “post_gp” with the __GeoDataFrame__ “tourist_out” based on a common column, which is “PracticeName” from “post_gp” and “Near_GP” from “tourist_out”. The <cite>.merge</cite> operation is performed using an __inner <a href="#id17"><span class="problematic" id="id24">join__</span></a>, ensuring that only rows with matching values in both DataFrames are included in the resulting merged DataFrame named “merge”.
#
# * <cite>pd.merge()</cite>: This function from the Pandas library is used to merge two __DataFrames__.
# * <cite>post_gp</cite> and <cite>tourist_out</cite>: These are the __DataFrames__ to be merged.
# * <cite>left_on=”PracticeName”</cite> and <cite>right_on=”Near_GP”</cite>: These parameters specify the columns from the left and right __DataFrames__ that will be used for the merge operation. In this case, “PracticeName” from post_gp and “Near_GP” from tourist_out are used.
# * <cite>how=”inner”</cite>: This parameter specifies the type of merge to perform. In this case, an inner join is performed, meaning only the rows with matching values in both __DataFrames__ will be included in the merged DataFrame.</p>
<p># In[ ]:</p>
<p># Merge DataFrame and GeoDataFrame
merged = pd.merge(post_gp, tourist_out,left_on=”PracticeName”, right_on=”Near_GP”, how=”inner”)</p>
<p># Inspect the first few rows of the “merged” __DataFrame__</p>
<p># In[ ]:</p>
<p>#verify the header
merged.head()</p>
<p># This code filters the necessary columns from the merged __DataFrame__ “merged”, creates a new __DataFrame__ named output, renames the columns, and saves the result to a CSV file.
# * The <cite>pd.DataFrame(…)`[(documentation)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html) function creates a new __DataFrame__ named output with the filtered columns from the previous step.
# * The `.rename`[(documentation)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html) function  is used to rename specified columns to defined new names.
# * The `inplace=True</cite> function ensures that the changes are made directly to the output DataFrame.
# * The <a href="#id15"><span class="problematic" id="id16">`</span></a>.to_csv`[(documentation)](<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html</a>) function saves the output DataFrame to a CSV file.</p>
<p># In[ ]:</p>
<p># This code filters the necessary columns
#rename specified columns to defined new names
#saves the output DataFrame to a CSV file.
output = pd.DataFrame(merged[[“SITE”, “Near_T_Hub”,”Trans_Dist”,”Near_GP”, “GP_Dist”,”postcode”]])
output.rename(columns={“SITE”:”Tourist Sites”, “postcode”:”PostCode”},inplace=True)
output.to_csv(“data_files/NI_Tourist_trans_GP_Dist.csv”)</p>
<p># ### iii. Coastline spots intergration
#
# We’ll locate the closest transport hub along with its distance and also identify the nearest GP surgery and its distance from the Coastline spots.
#
# ### Getting Started
#
# The necessary libraries have already been imported in section 4. If you’d like to start from the middle, navigate back to section 4 and import the libraries. Alternatively, you can define new libraries by adding a new cell here.</p>
<p># Read the downloaded shapefile data (a __GeoDataFrame__) in coastline.</p>
<p># In[ ]:</p>
<p># Read Places_to_Visit_in_Causeway_Coast_and_Glens
coastline_tmp = gpd.read_file(“data_files/download_data/Places_to_Visit_in_Causeway_Coast_and_Glens.shp”) # Path to the input shapefile of Places to Visit in coastaline data</p>
<p># Check few rows using <cite>.head()</cite> function</p>
<p># In[ ]:</p>
<p># check the header
coastline_tmp.head()</p>
<p># The code functions similarly to the previous step, with the main difference being that the “coastal_tmp” geometry represents points, so there’s no need to calculate the centroid as done previously.</p>
<p># In[ ]:</p>
<p># for each coastline spots ,find the closest bus/train station
# Record the Shortest distance in km and the name of the station.
for ind, row in coastline_tmp.to_crs(“epsg:2157”).iterrows():</p>
<blockquote>
<div><p>pt = row[“geometry”] # consider geometry point.</p>
<p>distance_trans = transport.distance(pt) # find the distance between the coastline spots and all train station
distance_postgp = post_gp.distance(pt) # find the distance between the coastline spots and all GP pratices</p>
<p>min_ind_trans = distance_trans.argmin() # get the index of minimum value
min_dist_trans = distance_trans.min() # get the minimum distance</p>
<p>min_ind_postgp = distance_postgp.argmin()
min_dist_postgp = distance_postgp.min()</p>
<p># define column header
coastline_tmp.loc[ind, “Near_T_Hub”] = transport.loc[min_ind_trans].Station.title() # assigns the name of the nearest transport hub and capitalizes the first letter of each word in the station name
coastline_tmp.loc[ind, “Near_GP”] = post_gp.loc[min_ind_postgp].PracticeName #assigns the name of the nearest GP Surgery</p>
<p># add distance to the closest transport hub
coastline_tmp.loc[ind, “Trans_Dist”] = min_dist_trans / 1000 # distance in km
coastline_tmp.loc[ind, “GP_Dist”] = min_dist_postgp / 1000</p>
</div></blockquote>
<p># Distance rounding to the centimeter accuracy.</p>
<p># In[ ]:</p>
<p># round the distance to cm accuracy (2 decimal places)
coastline_tmp.Trans_Dist = coastline_tmp.Trans_Dist.round(2)
coastline_tmp.GP_Dist = coastline_tmp.GP_Dist.round(2)</p>
<p># Verify the results</p>
<p># In[ ]:</p>
<p>#verify the header
coastline_tmp.head()</p>
<p># This code creates a GeoDataFrame containing selected columns. It then converts the CRS to WGS84 and saves as a GeoJSON file.</p>
<p># In[ ]:</p>
<p># This code filters the necessary columns
# rename specified columns to defined new names
# saves the output DataFrame to a CSV file.
coastal_out = gpd.GeoDataFrame(coastline_tmp[[“Name”, “Website”,”geometry”, “Near_T_Hub”,”Trans_Dist”,”Near_GP”, “GP_Dist”,”Postcode”]])
coastal_out.to_crs(“epsg:4326”)
coastal_out.to_file(“data_files/NI_Coastal_spots.geojson”,driver=”GeoJSON”)</p>
<p># In[ ]:</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="NI_Tourist_Map_doc.html" class="btn btn-neutral float-left" title="1. NI Tourist Map" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../Other/Sphinx_and_HTML_Web_Publishing.html" class="btn btn-neutral float-right" title="1. Sphinx and HTML Web Publishing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Serenee Osman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>